<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="Content-Security-Policy"
        content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdn.jsdelivr.net; connect-src 'self' https://geaqvvbkwgfoxiakzums.supabase.co wss://geaqvvbkwgfoxiakzums.supabase.co https://cdn.jsdelivr.net; style-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net; img-src 'self' data:;">
  <title>ToastMasters Ratings Dashboard</title>
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" crossorigin="anonymous">
  <style>
    :root {
      color-scheme: light;
    }

    body {
      margin: 0;
      background: #f5f7fb;
      font-family: "Inter", "Segoe UI", system-ui, sans-serif;
      color: #212529;
    }

    header h1 {
      margin-bottom: 0.25rem;
      font-weight: 600;
    }

    header p {
      margin-bottom: 0;
      color: #6c757d;
    }

    .session-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.4rem 0.9rem;
      border-radius: 999px;
      background: rgba(13, 110, 253, 0.1);
      color: #0d3d96;
      font-weight: 600;
      font-size: 0.9rem;
    }

    #share-link-panel .card-body {
      padding: 1.75rem 1.75rem 1.5rem;
    }

    .share-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      justify-content: flex-start;
    }

    .share-stack {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .share-stack .share-actions {
      justify-content: flex-start;
    }

    .btn-gradient {
      background: linear-gradient(135deg, #0d6efd, #6610f2);
      color: #fff;
      border: none;
      box-shadow: 0 12px 28px rgba(13, 110, 253, 0.25);
    }

    .btn-gradient:disabled {
      background: #c8d4fb;
      box-shadow: none;
    }

    .btn-gradient:not(:disabled):hover {
      color: #fff;
      transform: translateY(-1px);
    }

    #copy-status {
      min-height: 1.2rem;
      text-align: left;
      font-size: 0.9rem;
      margin-top: 0;
      color: #17683b;
    }

    #copy-status.error {
      color: #c62828;
    }

    .qr-inline img {
      max-width: 180px;
      width: 100%;
      height: auto;
    }

    .qr-inline {
      border: 1px solid rgba(15, 23, 42, 0.08);
    }

    .empty-state {
      padding: 32px;
      text-align: center;
      background: rgba(13, 27, 61, 0.04);
      border: 1px dashed rgba(13, 27, 61, 0.18);
      border-radius: 16px;
      font-weight: 600;
      color: rgba(13, 27, 61, 0.55);
    }

    #leaderboardSection table thead th {
      text-transform: uppercase;
      letter-spacing: 0.04em;
      font-size: 0.75rem;
      color: #6c757d;
    }

    .note {
      margin-top: 2rem;
      font-size: 0.9rem;
      color: #6c757d;
      text-align: center;
    }

    @media (max-width: 640px) {
      body {
        padding: 18px;
      }
    }
  </style>
</head>
<body>
  <div class="container-lg py-4">
    <header class="mb-4">
      <div class="d-flex flex-column gap-4">
        <div>
          <h1 class="fw-semibold mb-1">ToastMasters Ratings Dashboard</h1>
          <p class="mb-0 text-muted">Live standings update as audience feedback rolls in.</p>
        </div>
        <div class="row g-4 align-items-stretch">
          <div class="col-lg-4">
            <div class="qr-inline text-center p-3 p-md-4 bg-white rounded-4 shadow-sm border h-100">
              <p class="mb-2 text-muted small" id="qr-inline-label">Scan to rate all speakers</p>
              <div id="qr-inline-output"></div>
            </div>
          </div>
          <div class="col-lg-8">
            <div class="share-stack bg-white rounded-4 shadow-sm border p-3 p-md-4 h-100 d-flex flex-column gap-3">
              <span class="session-pill align-self-start">Session <span class="fw-semibold" id="sessionIdLabel">—</span></span>
              <div class="share-actions d-flex flex-wrap gap-2">
                <button type="button" class="btn btn-gradient px-4" id="group-rating-button" disabled>Open audience rating form</button>
                <button type="button" class="btn btn-outline-secondary px-4" id="copy-rating-link" disabled>Copy rating link</button>
              </div>
              <p class="text-muted small mb-0">Share the audience rating link so attendees can vote from their own device.</p>
              <span id="copy-status" class="copy-status align-self-start" aria-live="polite"></span>
            </div>
          </div>
        </div>
      </div>
    </header>

    <section class="card shadow-sm mb-4" id="leaderboardSection" hidden>
      <div class="card-body">
        <h2 class="h4 mb-3">Live Leaderboard</h2>
        <div class="table-responsive">
          <table class="table table-striped align-middle mb-0">
            <thead>
              <tr>
                <th scope="col">#</th>
                <th scope="col">Speaker</th>
                <th scope="col">Topic</th>
                <th scope="col">Average</th>
                <th scope="col">Votes</th>
              </tr>
            </thead>
            <tbody id="leaderboardBody"></tbody>
          </table>
        </div>
      </div>
    </section>


  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="supabase-config.js"></script>
  <script src="qrcodegen.js"></script>

  <script>
    (function() {
      const params = new URLSearchParams(window.location.search);
      const sessionId = params.get('session');
      if (!sessionId) {
        document.body.innerHTML = '<main><h1>Missing session information</h1><p>Re-open the dashboard from the timer page.</p></main>';
        return;
      }

      const fallbackOrder = new Map();
      const speakerMeta = new Map();
      const SNAPSHOT_STORAGE_KEY = 'tmTimer.ratings.snapshot';

      const supabaseConfig = window.tmSupabaseConfig || {};
      const supabase = (window.supabase && supabaseConfig.url && supabaseConfig.anonKey)
        ? window.supabase.createClient(supabaseConfig.url, supabaseConfig.anonKey)
        : null;
      if (!supabase) {
        console.warn('Supabase client unavailable; ratings will only sync on this device.');
      }

      let speakers = [];
      let realtimeChannel = null;
      let ratingsPoll = null;
      let lastRosterSignature = null;
      const RATINGS_POLL_INTERVAL = 5000;

      const signalKey = `tm_rating_signal_${sessionId}`;
      const cacheKey = `tm_ratings_cache_${sessionId}`;
      const ratings = Object.create(null);
      const processedLocalIds = new Set();
      const processedRemoteIds = new Set();
      let hydrateDebounce = null;

      const leaderboardSection = document.getElementById('leaderboardSection');
      const leaderboardBody = document.getElementById('leaderboardBody');
      const groupRatingButton = document.getElementById('group-rating-button');

      const copyLinkBtn = document.getElementById('copy-rating-link');
      const copyStatusEl = document.getElementById('copy-status');
      const qrInlineOutput = document.getElementById('qr-inline-output');
      const qrInlineLabel = document.getElementById('qr-inline-label');
      const sessionIdLabel = document.getElementById('sessionIdLabel');
      const defaultQrLabel = qrInlineLabel?.textContent || 'Scan to rate all speakers';

      if (sessionIdLabel) {
        sessionIdLabel.textContent = sessionId;
      }

      let copyStatusTimeout;
      let latestRatingUrl = '';

      const ensureArray = (id) => {
        if (!ratings[id]) ratings[id] = [];
        return ratings[id];
      };

      function sanitizeRoster(list) {
        if (!Array.isArray(list)) return [];
        return list.map((entry, index) => {
          const safe = entry || {};
          const id = safe.id || `sp-${index + 1}`;
          return {
            id,
            name: (safe.name ?? '').trim() || `Speaker ${index + 1}`,
            topic: (safe.topic ?? '').trim(),
            status: safe.status ?? '',
            totalTime: safe.totalTime ?? ''
          };
        });
      }

      function readRosterSnapshot() {
        try {
          const raw = localStorage.getItem(SNAPSHOT_STORAGE_KEY);
          if (!raw) return null;
          const parsed = JSON.parse(raw);
          if (!parsed || parsed.sessionId !== sessionId) return null;
          if (!Array.isArray(parsed.roster)) return [];
          return sanitizeRoster(parsed.roster);
        } catch (err) {
          console.warn('Unable to read roster snapshot', err);
          return null;
        }
      }

      function rosterSignature(list) {
        if (!Array.isArray(list)) return '';
        return list.map((entry) => `${entry.id}:${entry.name}:${entry.topic}:${entry.status}`).join('|');
      }

      const buildGroupRatingUrl = () => {
        const url = new URL('multi-speaker-rating.html', window.location.href);
        url.searchParams.set('session', sessionId);
        return url;
      };

      const toggleShareButtons = (enabled) => {
        if (groupRatingButton) {
          groupRatingButton.disabled = !enabled;
          if (!enabled) delete groupRatingButton.dataset.url;
        }
        if (copyLinkBtn) {
          copyLinkBtn.disabled = !enabled;
          if (!enabled) delete copyLinkBtn.dataset.url;
        }
        if (!enabled) {
          if (qrInlineOutput) qrInlineOutput.innerHTML = '';
          if (qrInlineLabel) {
            qrInlineLabel.textContent = 'Awaiting roster for QR code';
            qrInlineLabel.classList.add('text-muted');
          }
        } else if (qrInlineLabel) {
          qrInlineLabel.textContent = defaultQrLabel;
          qrInlineLabel.classList.remove('text-muted');
        }
      };

      function renderEmptyState() {
        toggleShareButtons(false);
        latestRatingUrl = '';
        if (leaderboardSection) {
          leaderboardSection.hidden = true;
        }
        if (leaderboardBody) {
          leaderboardBody.innerHTML = '';
        }
      }

      function applyRosterUpdate(list) {
        const cleaned = sanitizeRoster(list);
        const signature = rosterSignature(cleaned);
        if (signature === lastRosterSignature) return cleaned.length;
        lastRosterSignature = signature;
        fallbackOrder.clear();
        speakerMeta.clear();
        cleaned.forEach((entry, index) => {
          fallbackOrder.set(entry.id, index);
          speakerMeta.set(entry.id, entry);
        });
        const hadSpeakers = speakers.length > 0;
        speakers = cleaned;
        if (!speakers.length) {
          if (!hadSpeakers) {
            Object.keys(ratings).forEach((key) => { delete ratings[key]; });
            renderEmptyState();
            persistCache();
          }
          return 0;
        }
        speakers.forEach((speaker) => ensureArray(speaker.id));
        updateRatingDestination();
        renderLeaderboard();
        persistCache();
        return speakers.length;
      }

      const setCopyStatus = (message, { isError = false, persist = false } = {}) => {
        if (!copyStatusEl) return;
        if (copyStatusTimeout) {
          clearTimeout(copyStatusTimeout);
        }
        copyStatusEl.textContent = message;
        copyStatusEl.classList.toggle('error', !!isError);
        if (!persist && message) {
          copyStatusTimeout = setTimeout(() => {
            copyStatusEl.textContent = '';
            copyStatusEl.classList.remove('error');
          }, 3500);
        }
      };

      const updateRatingDestination = () => {
        if (!speakers.length) {
          latestRatingUrl = '';
          toggleShareButtons(false);
          return '';
        }
        const ratingUrl = buildGroupRatingUrl().toString();
        latestRatingUrl = ratingUrl;
        if (groupRatingButton) {
          groupRatingButton.disabled = false;
          groupRatingButton.dataset.url = ratingUrl;
        }
        if (copyLinkBtn) {
          copyLinkBtn.disabled = false;
          copyLinkBtn.dataset.url = ratingUrl;
        }
        renderInlineQr(ratingUrl);
        return ratingUrl;
      };

      const renderInlineQr = (ratingUrl = latestRatingUrl) => {
        if (!qrInlineOutput) return;
        const url = ratingUrl || latestRatingUrl;
        if (!url) {
          qrInlineOutput.innerHTML = '';
          return;
        }
        qrInlineOutput.innerHTML = '';
        try {
          if (!window.qrcodegen || !window.qrcodegen.QrCode) {
            throw new Error('QR library unavailable');
          }
          const qr = window.qrcodegen.QrCode.encodeText(url, window.qrcodegen.QrCode.Ecc.MEDIUM);
          const scale = 6;
          const border = 3;
          const size = qr.size;
          const canvasSize = (size + border * 2) * scale;
          const canvas = document.createElement('canvas');
          canvas.width = canvasSize;
          canvas.height = canvasSize;
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(0, 0, canvasSize, canvasSize);
          ctx.fillStyle = '#000000';
          for (let y = 0; y < size; y += 1) {
            for (let x = 0; x < size; x += 1) {
              if (qr.getModule(x, y)) {
                ctx.fillRect((x + border) * scale, (y + border) * scale, scale, scale);
              }
            }
          }
          const img = document.createElement('img');
          img.src = canvas.toDataURL('image/png');
          img.alt = 'QR code linking to the audience rating form';
          qrInlineOutput.appendChild(img);
          if (qrInlineLabel) {
            qrInlineLabel.hidden = false;
            qrInlineLabel.textContent = defaultQrLabel;
            qrInlineLabel.classList.remove('text-muted');
          }
        } catch (error) {
          console.error('Failed to render QR code', error);
          const fallback = document.createElement('div');
          fallback.className = 'qr-fallback';
          fallback.textContent = `QR code unavailable: ${error?.message || error}`;
          qrInlineOutput.appendChild(fallback);
          if (qrInlineLabel) {
            qrInlineLabel.hidden = false;
            qrInlineLabel.textContent = 'QR code unavailable';
            qrInlineLabel.classList.add('text-muted');
          }
        }
      };
      groupRatingButton?.addEventListener('click', () => {
        const ratingUrl = latestRatingUrl || updateRatingDestination();
        if (!ratingUrl) {
          alert('No speakers are available for rating yet.');
          return;
        }
        window.open(ratingUrl, '_blank', 'noopener');
      });

      copyLinkBtn?.addEventListener('click', async () => {
        const ratingUrl = latestRatingUrl || updateRatingDestination();
        if (!ratingUrl) {
          setCopyStatus('No rating link available.', { isError: true });
          return;
        }
        const handleSuccess = () => setCopyStatus('Link copied to clipboard.');
        const handleFailure = (error) => {
          console.error('Failed to copy rating link', error);
          setCopyStatus(`Copy failed. Link: ${ratingUrl}`, { isError: true, persist: true });
        };
        try {
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(ratingUrl);
            handleSuccess();
            return;
          }
          throw new Error('Clipboard API not available');
        } catch (err) {
          try {
            const textarea = document.createElement('textarea');
            textarea.value = ratingUrl;
            textarea.setAttribute('readonly', '');
            textarea.style.position = 'absolute';
            textarea.style.left = '-9999px';
            document.body.appendChild(textarea);
            textarea.select();
            const success = document.execCommand && document.execCommand('copy');
            document.body.removeChild(textarea);
            if (success) {
              handleSuccess();
              return;
            }
            handleFailure(err);
          } catch (fallbackErr) {
            handleFailure(fallbackErr);
          }
        }
      });

      const scheduleHydrate = (delay = 400) => {
        if (!supabase) return;
        if (hydrateDebounce) clearTimeout(hydrateDebounce);
        hydrateDebounce = setTimeout(() => {
          hydrateSupabaseRatings();
        }, delay);
      };

      const loadCache = () => {
        try {
          const stored = localStorage.getItem(cacheKey);
          if (stored) {
            const obj = JSON.parse(stored);
            Object.keys(obj).forEach((key) => {
              if (Array.isArray(obj[key])) {
                ratings[key] = obj[key].map((value) => Number(value)).filter((value) => Number.isFinite(value));
              }
            });
          }
        } catch (err) {
          console.warn('Unable to restore cached ratings', err);
        }
      };

      const persistCache = () => {
        try {
          localStorage.setItem(cacheKey, JSON.stringify(ratings));
        } catch (err) {
          console.warn('Failed to persist ratings cache', err);
        }
      };

      const renderLeaderboard = () => {
        if (!leaderboardSection || !leaderboardBody) return;
        const rows = Object.entries(ratings).map(([id, values]) => {
          const count = Array.isArray(values) ? values.length : 0;
          const average = count ? values.reduce((sum, val) => sum + val, 0) / count : 0;
          const speaker = speakers.find((entry) => entry.id === id) || speakerMeta.get(id) || {
            id,
            name: `Speaker ${fallbackOrder.has(id) ? String(fallbackOrder.get(id) + 1) : ''}`.trim() || id,
            topic: '—'
          };
          return { id, speaker, count, average };
        }).filter((item) => item.count > 0);
        console.log('[dashboard] renderLeaderboard rows', rows);

        if (!rows.length) {
          leaderboardSection.hidden = false;
          leaderboardBody.innerHTML = '';
          const tr = document.createElement('tr');
          const td = document.createElement('td');
          td.colSpan = 5;
          td.className = 'text-center text-muted py-3';
          td.textContent = 'No ratings submitted yet.';
          tr.appendChild(td);
          leaderboardBody.appendChild(tr);
          return;
        }

        rows.sort((a, b) => {
          if (b.average !== a.average) return b.average - a.average;
          if (b.count !== a.count) return b.count - a.count;
          return a.speaker.name.localeCompare(b.speaker.name);
        });

        leaderboardSection.hidden = false;
        leaderboardBody.innerHTML = '';
        rows.forEach((row, index) => {
          const tr = document.createElement('tr');
          const pos = document.createElement('td');
          pos.textContent = String(index + 1);
          const name = document.createElement('td');
          name.textContent = row.speaker.name || row.id;
          const topic = document.createElement('td');
          topic.textContent = row.speaker.topic || '—';
          const avg = document.createElement('td');
          avg.textContent = row.average.toFixed(2);
          const votes = document.createElement('td');
          votes.textContent = row.count === 1 ? '1 vote' : `${row.count} votes`;
          tr.append(pos, name, topic, avg, votes);
          leaderboardBody.appendChild(tr);
        });
      };

      const applyRatingEntry = (entry) => {
        if (!entry || typeof entry !== 'object') return;
        const speakerId = entry.speakerId ?? entry.speaker_id;
        if (!speakerId) return;
        const numericRating = Number(entry.rating ?? entry.value);
        if (!Number.isFinite(numericRating) || numericRating < 1 || numericRating > 5) return;

        const localKey = entry.uid || entry.id || null;
        if (localKey) {
          if (processedLocalIds.has(localKey)) return;
          processedLocalIds.add(localKey);
          scheduleHydrate(800);
        }

        const remoteKey = entry.submitted_at ? `${speakerId}|${entry.submitted_at}` : null;
        if (remoteKey) {
          if (processedRemoteIds.has(remoteKey)) return;
          processedRemoteIds.add(remoteKey);
        }

        const arr = ensureArray(speakerId);
        arr.push(numericRating);
        persistCache();
        renderLeaderboard();
      };

      const ingestRatingMessage = (message) => {
        if (!message) return;
        if (Array.isArray(message)) {
          message.forEach(ingestRatingMessage);
          return;
        }
        if (Array.isArray(message.entries)) {
          message.entries.forEach(ingestRatingMessage);
          scheduleHydrate(600);
          return;
        }
        if (message.payload) {
          ingestRatingMessage(message.payload);
          return;
        }
        if (message.entry) {
          ingestRatingMessage(message.entry);
          return;
        }
        applyRatingEntry(message);
      };

      const mapSpeakerRow = (row) => ({
        id: row.speaker_id || row.id,
        name: row.name || 'Speaker',
        topic: row.topic || '',
        orderIndex: typeof row.order_index === 'number' ? row.order_index : null,
        status: row.status || '',
        totalTime: row.total_time || ''
      });

      const fetchSpeakersFromSupabase = async () => {
        if (!supabase) return null;
        try {
          const { data, error } = await supabase
            .from('speakers')
            .select('speaker_id,name,topic,order_index,total_time,status')
            .eq('session_id', sessionId)
            .order('order_index', { ascending: true });
          if (error) throw error;
          if (!data) return [];
          if (!data.length) return [];
          const mapped = data.map(mapSpeakerRow);
          mapped.forEach((entry, index) => {
            fallbackOrder.set(entry.id, index);
            speakerMeta.set(entry.id, entry);
          });
          return mapped;
        } catch (err) {
          console.warn('Unable to fetch speakers from Supabase', err);
          return null;
        }
      };

      const refreshSpeakersFromRemote = async () => {
        const hadRoster = speakers.length > 0;
        const remote = await fetchSpeakersFromSupabase();
        if (remote === null) return;
        if (!remote.length) {
          if (!hadRoster) {
            applyRosterUpdate([]);
          }
          return;
        }
        remote.forEach((entry) => ensureArray(entry.id));
        speakers = remote;
        processedRemoteIds.clear();
        updateRatingDestination();
        renderLeaderboard();
        persistCache();
      };

      const hydrateSupabaseRatings = async () => {
        if (!supabase) return;
        try {
          const { data, error } = await supabase
            .from('ratings')
            .select('speaker_id,rating,submitted_at')
            .eq('session_id', sessionId)
            .order('submitted_at', { ascending: true });
          if (error) throw error;
          const rows = Array.isArray(data) ? data : [];
          console.log('[dashboard] hydrate rows', rows);
          
          // Clear and rebuild ratings from Supabase
          Object.keys(ratings).forEach((key) => { ratings[key] = []; });
          processedRemoteIds.clear();
          
          rows.forEach((row) => {
            const speakerId = row.speaker_id;
            const numericRating = Number(row.rating);
            if (!speakerId || !Number.isFinite(numericRating) || numericRating < 1 || numericRating > 5) return;
            
            const key = `${speakerId}|${row.submitted_at}`;
            processedRemoteIds.add(key);
            
            const arr = ensureArray(speakerId);
            arr.push(numericRating);
          });
          
          renderLeaderboard();
          persistCache();
        } catch (err) {
          console.warn('Unable to hydrate ratings from Supabase', err);
        }
      };

      const subscribeToSupabase = () => {
        if (!supabase) return;
        realtimeChannel = supabase.channel(`dashboard-${sessionId}`)
          .on('postgres_changes', {
            event: 'INSERT',
            schema: 'public',
            table: 'ratings',
            filter: `session_id=eq.${sessionId}`
          }, (payload) => {
            const key = `${payload.new.speaker_id}|${payload.new.submitted_at}`;
            processedRemoteIds.add(key);
            hydrateSupabaseRatings();
          })
          .on('postgres_changes', {
            event: 'DELETE',
            schema: 'public',
            table: 'ratings',
            filter: `session_id=eq.${sessionId}`
          }, () => {
            hydrateSupabaseRatings();
          })
          .on('postgres_changes', {
            event: '*',
            schema: 'public',
            table: 'speakers',
            filter: `session_id=eq.${sessionId}`
          }, () => {
            refreshSpeakersFromRemote();
          })
          .subscribe((status, err) => {
            if (err) {
              console.warn('Supabase realtime subscription error', err);
            }
            if (status === 'CHANNEL_ERROR') {
              console.warn('Supabase realtime channel error');
            }
          });
      };

      const startRatingsPoll = () => {
        if (!supabase) return;
        if (ratingsPoll) clearInterval(ratingsPoll);
        ratingsPoll = setInterval(async () => {
          await refreshSpeakersFromRemote();
          await hydrateSupabaseRatings();
        }, RATINGS_POLL_INTERVAL);
        (async () => {
          await refreshSpeakersFromRemote();
          await hydrateSupabaseRatings();
        })();
      };

      window.addEventListener('storage', (event) => {
        if (event.key === SNAPSHOT_STORAGE_KEY) {
          if (!event.newValue) {
            applyRosterUpdate([]);
            return;
          }
          try {
            const parsed = JSON.parse(event.newValue);
            if (parsed && parsed.sessionId === sessionId) {
              applyRosterUpdate(parsed.roster || []);
            }
          } catch (err) {
            console.warn('Invalid roster snapshot payload', err);
          }
          return;
        }
        if (event.key === signalKey && event.newValue) {
          try {
            const payload = JSON.parse(event.newValue);
            ingestRatingMessage(payload);
          } catch (err) {
            console.warn('Invalid rating payload', err);
          }
        }
      });

      window.addEventListener('message', (event) => {
        const data = event?.data;
        if (!data) return;
        if (data.sessionId && data.sessionId !== sessionId) return;
        if (data.type && data.type !== 'tm-rating' && data.type !== 'tm-rating-batch') return;
        if (!data.payload && !data.entries && !data.speakerId && !data.speaker_id) return;
        ingestRatingMessage(data);
      });

      const ratingsChannel = window.BroadcastChannel ? new BroadcastChannel('tm_ratings_channel') : null;

      let lastSignalValue = null;
      const processSignalValue = () => {
        try {
          const current = localStorage.getItem(signalKey);
          if (!current || current === lastSignalValue) return;
          lastSignalValue = current;
          const payload = JSON.parse(current);
          ingestRatingMessage(payload);
        } catch (err) {
          console.warn('Failed to process stored rating payload', err);
        }
      };

      processSignalValue();
      const signalPoll = setInterval(processSignalValue, 1500);

      ratingsChannel?.addEventListener('message', (event) => {
        const data = event?.data;
        if (!data) return;
        if (data.sessionId && data.sessionId !== sessionId) return;
        ingestRatingMessage(data);
      });

      if (!supabase) {
        loadCache();
      } else {
        Object.keys(ratings).forEach((key) => { ratings[key] = []; });
      }

      const initialize = async () => {
        const snapshotRoster = readRosterSnapshot();
        if (snapshotRoster !== null) {
          applyRosterUpdate(snapshotRoster);
        } else {
          applyRosterUpdate(speakers);
        }

        if (supabase) {
          const remote = await fetchSpeakersFromSupabase();
          if (Array.isArray(remote) && remote.length) {
            applyRosterUpdate(remote);
          }
        }

        if (!speakers.length) {
          return;
        }

        if (supabase) {
          await hydrateSupabaseRatings();
          subscribeToSupabase();
          startRatingsPoll();
        }
      };

      initialize();

      window.addEventListener('beforeunload', () => {
        if (ratingsChannel) {
          try { ratingsChannel.close(); } catch (_) {}
        }
        if (realtimeChannel) {
          try { realtimeChannel.unsubscribe(); } catch (_) {}
        }
        clearInterval(signalPoll);
        if (ratingsPoll) {
          clearInterval(ratingsPoll);
          ratingsPoll = null;
        }
      });
    })();
  </script>

    <footer class="py-3 text-muted small">
      <div class="d-flex justify-content-center">
        <span class="text-center">Created by <a href="https://www.linkedin.com/in/tusharvartak/" target="_blank" rel="noopener" class="text-decoration-none fw-semibold">Tushar Vartak</a></span>
      </div>
    </footer>

</body>
</html>

